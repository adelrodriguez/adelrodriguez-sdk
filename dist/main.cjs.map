{"mappings":"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","sources":["src/index.ts","src/resources/movies.ts","src/resources/base.ts","src/resources/quotes.ts"],"sourcesContent":["import { Movies } from \"./resources/movies\"\nimport { Quotes } from \"./resources/quotes\"\nimport { ClientConfig } from \"./resources/base\"\n\nexport default class Client {\n  public movies: Movies\n  public quotes: Quotes\n\n  constructor(config: ClientConfig) {\n    this.movies = new Movies(config)\n    this.quotes = new Quotes(config)\n  }\n}\n","import {\n  APIResponse,\n  FilterOptions,\n  PaginationOptions,\n  SortOptions,\n  Base,\n} from \"./base\"\nimport { Quote } from \"./quotes\"\n\nexport type Movie = {\n  _id: string\n  name: string\n  runtimeInMinutes: number\n  budgetInMillions: number\n  boxOfficeRevenueInMillions: number\n  academyAwardNominations: number\n  academyAwardWins: number\n  rottenTomatoesScore: number\n}\n\nexport class Movies extends Base {\n  /**\n   * Fetches a list of movies\n   * @returns An API response with a list of movies\n   */\n  public async list(\n    pagination?: PaginationOptions,\n    sort?: SortOptions,\n    filter?: FilterOptions\n  ) {\n    return this.request<Movie>(\"/movie\", { pagination, sort, filter })\n  }\n\n  /**\n   * Fetches a single movie\n   * @param id The id of the movie\n   * @returns An API response with a single movie\n   */\n  public async get(id: string): Promise<APIResponse<Movie>> {\n    return this.request<Movie>(`/movie/${id}`)\n  }\n\n  /**\n   * Fetches a list of quotes for a movie\n   * @param id The id of the movie to fetch quotes for\n   * @returns An API response with a list of quotes from the movie\n   */\n  public async getQuotes(\n    id: string,\n    pagination?: PaginationOptions,\n    sort?: SortOptions,\n    filter?: FilterOptions\n  ): Promise<APIResponse<Quote>> {\n    return this.request<Quote>(`/movie/${id}/quote`, {\n      pagination,\n      sort,\n      filter,\n    })\n  }\n}\n","import \"isomorphic-fetch\"\n\nimport { Movie } from \"./movies\"\nimport { Quote } from \"./quotes\"\n\nexport type ClientConfig = {\n  apiKey: string\n  version?: string\n}\n\nexport type APIResponse<T> = {\n  docs: T[]\n  total: number\n  limit: number\n  offset: number\n  page: number\n  pages: number\n}\n\nexport type RequestOptions = {\n  pagination?: PaginationOptions\n  sort?: SortOptions\n  filter?: FilterOptions\n}\n\nexport type PaginationOptions = {\n  limit?: number\n  page?: number\n  offset?: number\n}\n\ntype ResourceKey = Exclude<keyof (Quote & Movie), \"id\" | \"_id\">\n\nexport type SortOptions = [ResourceKey, \"asc\" | \"desc\"]\n\n/**\n * The filtering works by casting simple url parameter expressions to MongoDB\n * lookup expressions and can be applied to any available key on the data\n * models.\n */\nexport type FilterOptions = {\n  /**\n   * Accepts either a string or an array of strings. The string can be a regex.\n   */\n  match?: { [key in `${ResourceKey}` | `${ResourceKey}!`]?: string | string[] }\n  range?: { [key in ResourceKey]?: [\">\" | \"<\" | \"<=\" | \">=\", number] }\n}\n\nexport abstract class Base {\n  private apiKey: string\n  private version?: string\n\n  private readonly BASE_URL = \"https://the-one-api.dev/\"\n\n  constructor(config: ClientConfig) {\n    if (!config.apiKey) throw new Error(\"No API key provided\")\n\n    this.apiKey = config.apiKey\n    this.version = config.version || \"v2\"\n  }\n\n  protected async request<T = unknown>(\n    path: string,\n    options?: RequestOptions,\n    config?: RequestInit\n  ): Promise<APIResponse<T>> {\n    const url = new URL(`${this.BASE_URL}${this.version}${path}`)\n    const searchParams = this.generateSearchParams(options)\n    url.search = searchParams\n\n    const headers = new Headers({\n      Authorization: `Bearer ${this.apiKey}`,\n      Accept: \"application/json\",\n    })\n\n    const response = await fetch(url, {\n      ...config,\n      headers,\n    })\n\n    if (response.status === 429) {\n      throw new Error(\"Rate limit exceeded\")\n    }\n\n    return response.json()\n  }\n\n  private generateSearchParams(options?: RequestOptions): string {\n    const params = new URLSearchParams()\n\n    if (options?.pagination) {\n      const { limit, page, offset } = options.pagination\n\n      if (limit) params.append(\"limit\", limit.toString())\n      if (page) params.append(\"page\", page.toString())\n      if (offset) params.append(\"offset\", offset.toString())\n    }\n\n    if (options?.sort) {\n      const [key, order] = options.sort\n\n      params.append(\"sort\", `${key}:${order}`)\n    }\n\n    if (options?.filter?.match) {\n      const { match } = options.filter\n      for (const key in match) {\n        params.append(\n          key,\n          Array.isArray(match[key]) ? match[key].join(\",\") : match[key]\n        )\n      }\n    }\n\n    let paramsString = params.toString()\n\n    if (options?.filter?.range) {\n      const { range } = options.filter\n      for (const key in range) {\n        paramsString += `&${key}${range[key][0]}${range[key][1]}`\n      }\n    }\n\n    return paramsString\n  }\n}\n","import {\n  APIResponse,\n  Base,\n  FilterOptions,\n  PaginationOptions,\n  SortOptions,\n} from \"./base\"\n\nexport type Quote = {\n  _id: string\n  dialog: string\n  movie: string\n  character: string\n  id: string\n}\n\nexport class Quotes extends Base {\n  /**\n   * Fetches a list of quotes\n   * @returns An API response with a list of quotes\n   */\n  public async list(\n    pagination?: PaginationOptions,\n    sort?: SortOptions,\n    filter?: FilterOptions\n  ): Promise<APIResponse<Quote>> {\n    return this.request<Quote>(\"/quote\", { pagination, sort, filter })\n  }\n\n  /**\n   * Fetches a single quote\n   * @param id The id of the quote\n   * @returns An API response with a single quote\n   */\n  public async get(\n    id: string,\n    pagination?: PaginationOptions,\n    sort?: SortOptions,\n    filter?: FilterOptions\n  ): Promise<APIResponse<Quote>> {\n    return this.request<Quote>(`/quote/${id}`, { pagination, sort, filter })\n  }\n}\n"],"names":[],"version":3,"file":"main.cjs.map"}